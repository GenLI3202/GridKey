# CLAUDE.md

This file provides guidance to GEMINI CLI when working with code in this repository. To understand the ultimate purpose and structure of the project, please refer to `doc\whole_project_description.md`.

## Project Context

This is the Huawei TechArena 2025 BESS (Battery Energy Storage System) optimizer project for optimizing battery operations across European electricity markets. The system uses Mixed-Integer Linear Programming (MILP) to maximize profitability while managing battery degradation.

## Architecture Overview

### Core Model Hierarchy
The project implements three progressive optimization models:
- **Model I** (`BESSOptimizerModelI`): Base 4-market optimization (DA, FCR, aFRR capacity, aFRR energy)
- **Model II** (`BESSOptimizerModelII`): Model I + cyclic aging cost
- **Model III** (`BESSOptimizerModelIII`): Model II + calendar aging cost (full Phase II model)

### Key Components
- **py_script/core/optimizer.py**: Main optimization models using Pyomo MILP framework
- **py_script/data/market_data.py**: Market data loading and transformation
- **py_script/data/preprocessing.py**: Critical preprocessing for aFRR energy markets (0->NaN conversion)
- **py_script/visualization/**: Plotting utilities for results analysis

## Critical Data Processing

### aFRR Energy Market Preprocessing
**IMPORTANT**: aFRR energy price = 0 means market NOT activated, not free energy. All data loading functions automatically convert these to NaN to prevent false arbitrage opportunities.

### Data Sources and Pipeline

#### Primary Data Source (Submission)
- **Phase 2 Excel**: `data/TechArena2025_Phase2_data.xlsx`
  - Official Huawei TechArena 2025 Phase 2 data workbook
  - Contains all 4 markets: Day-ahead, FCR, aFRR capacity, aFRR energy
  - Wide-format: timestamp + columns for each country/direction
  - Matches Huawei submission requirements

#### Processed Data Formats
1. **Wide-format parquet** (intermediate): `data/parquet/{market}.parquet`
   - `day_ahead.parquet` - Day-ahead prices for all countries (15-min)
   - `fcr.parquet` - FCR capacity prices for all countries (4-hour blocks)
   - `afrr_capacity.parquet` - aFRR capacity prices Pos/Neg (4-hour blocks)
   - `afrr_energy.parquet` - aFRR energy prices Pos/Neg (15-min)

2. **Preprocessed country-specific** (validation fast path): `data/parquet/preprocessed/{country}.parquet`
   - Example: `de_lu.parquet`, `hu.parquet`, `at.parquet`, `ch.parquet`, `cz.parquet`
   - All 4 markets combined for each country
   - aFRR energy 0→NaN preprocessing applied
   - 4-hour block prices forward-filled to 15-min intervals
   - aFRR activation weights (EV weighting) included
   - **10-100x faster** than loading Excel
   - Generated by: `py_script/data/generate_preprocessed_country_data.py`

#### Configuration Files
- **Optimizer config**: `data/p2_config/*.json`:
  - `aging_config.json` - Degradation model parameters (cyclic + calendar)
  - `solver_config.json` - Solver settings (timeouts, tolerances)
  - `afrr_ev_weights_config.json` - aFRR activation probabilities (historical_activation section)
  - `investment.json` - Investment parameters
  - `mpc_config.json` - MPC controller settings

#### Data Loading Workflows

**Submission Path** (matches Huawei requirements):
```python
from py_script.core.optimizer import BESSOptimizerModelIII

optimizer = BESSOptimizerModelIII()
# Load from Excel (used for submission)
full_data = optimizer.load_and_preprocess_data('data/TechArena2025_Phase2_data.xlsx')
country_data = optimizer.extract_country_data(full_data, 'DE_LU')
```

**Validation Fast Path** (for rapid testing):
```python
from py_script.data.load_process_market_data import load_preprocessed_country_data

# Load preprocessed country data (10-100x faster)
country_data = load_preprocessed_country_data('DE_LU')
```

**Data Processing Steps** (automatic in both paths):
1. Load Excel or preprocessed parquet
2. Round timestamps to nearest second (fixes alignment issues)
3. Extract country-specific data (handles DE/DE_LU naming)
4. Forward-fill 4-hour block prices to 15-min intervals
5. Apply 0→NaN conversion for aFRR energy prices
6. Add aFRR activation weights from config


### Key Parameters
- **Countries**: DE_LU, AT, CH, HU, CZ
- **C-rates**: 0.25, 0.33, 0.5
- **Daily cycles**: 1.0, 1.5, 2.0
- **Alpha**: Degradation weight (0.5-1.0 typical)
- **Max AS ratio**: 0.8 (80% of power for ancillary services)

### Solver Configuration
The project auto-detects available MILP solvers in order: Gurobi > CPLEX > CBC > GLPK > HiGHS
- **CPLEX/Gurobi**: Best performance for large-scale problems
- **CBC**: Good open-source option
- **GLPK**: Fallback, slower for complex models

## Important Constraints

### Market Rules
- **Minimum bids**: FCR/aFRR = 1 MW, DA = 0.1 MW
- **Block structure**: AS markets use 4-hour blocks (6 blocks/day)
- **Exclusivity**: Cannot provide FCR and aFRR simultaneously (Cst-8)
- **Energy reserves**: Must maintain SOC for committed AS capacity (Cst-6)

### Battery Constraints
- **Capacity**: 4,472 kWh fixed
- **Efficiency**: 95% round-trip
- **SOC range**: 0-100% allowed
- **Power limits**: Based on C-rate configuration
- **Daily cycle limits**: Enforced per-day constraint (Cst-3)

## Model Formulation

### Objective Function (Model III)
Refer to `doc\p2_model\p2_bi_model_ggdp.tex`

### Key Decision Variables
- `p_ch[t]`, `p_dis[t]`: DA charge/discharge power
- `p_afrr_pos_e[t]`, `p_afrr_neg_e[t]`: aFRR energy bids
- `c_fcr[b]`, `c_afrr_pos[b]`, `c_afrr_neg[b]`: AS capacity bids (per block)
- `e_soc[t]`: State of charge trajectory
- `e_soc_seg[t,s]`: SOC in each degradation segment

## Testing and Validation

### Output Files saved destinations
- **Solutions**: 
   1. `validation_results/{validation_name}/solution_*.csv` (detailed decision variable time series)
   2. `validation_results/{validation_name}/performance_*.json` (Summary statistics, such as total profit including coponents profits, degradation costs, solver status, runtime, etc.)
- **Visualizations**: `validation_results/{validation_name}/plots/*.html` (or png)
- **Python Scripts**: Build minimum number of new wheels. When develop or test, first look at `./pyscript/` for existing utilities. If new scripts are needed, place in appropriate subfolder under `./pyscript/`.
- **Metadata**: JSON files with optimization statistics

### Visualization Outputs
Four standard plots generated:
1. **da_market_price_bid.html**: Day-ahead market participation
2. **afrr_energy_market_price_bid.html**: aFRR energy market (shows 0 prices correctly)
3. **capacity_markets_price_bid.html**: FCR/aFRR capacity reservations
4. **soc_and_power_bids.html**: Battery SOC trajectory with all power flows

## Important Implementation Details

### aFRR Energy Market Handling
- Preprocessed prices (NaN) used for optimization constraints
- Original prices (including 0) stored for visualization
- Revenue calculated using preprocessed prices (0 revenue when not activated)

### SOC Segmentation (Model II/III)
- 10 segments for cyclic aging (447.2 kWh each)
- Piecewise linear cost function: 0.0052-0.099 EUR/kWh
- Calendar aging: 5 SOC breakpoints with SOS2 variables

#### CRITICAL: LIFO Segment Filling Constraint
**Problem:** Without proper constraints, energy distributes equally across all segments (e.g., all segments at 11.47 kWh), violating the "stacked tank" LIFO principle.

**Solution (Implemented):** Based on Xu et al. 2017 (Theorem 1), added constraint in `optimizer.py:1715-1750`:
```python
# Segment j can only have energy if segment j-1 is FULL
e_soc_j[t, j-1] >= (E_seg[j-1] - epsilon) * z_segment_active[t, j]
```

**This ensures:**
- **Charging:** Fill segment 1 completely (447.2 kWh) before segment 2 receives any energy
- **Discharging:** Empty segment 10 completely before segment 9 discharges
- **Accuracy:** Degradation cost reflects actual cycling depth (Xu et al. 2017 benchmark)

**Reference:** `LIFO_SEGMENT_BUG_ANALYSIS.md` for detailed analysis

**Validation:** Check cyclic SOC stacked plot - lower segments should show complete fills before upper segments activate


## Known Issues and Workarounds

1. **aFRR zero prices**: Must use preprocessing to convert to NaN
2. **Solver timeouts**: Large problems may need increased time limits
3. **Memory usage**: Full-year optimization requires significant RAM
4. **Windows paths**: Use raw strings or forward slashes for file paths